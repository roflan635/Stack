// Task.cpp : Определяет функции для статической библиотеки.
//

#include "pch.h"
#include "Task.h"

struct Point // структура, описывающая точку
{
    int x, y;
};

struct StackItem // собственно сам элемент стека
{
    Point point; // точка
    StackItem* next;  // указатель на следующий элемент в списке
};

StackItem* stack = nullptr; // указатель на вершину стека, изначально стек пуст

bool IsEmpty() // функция проверяет пуст ли стек
{
    return stack == nullptr;
}

void Push(const Point& point) // Добавление точки в стек (аналог функции AddFirst линейного списка)
{
    //StackItem* item = new StackItem{ point, stack }; // этой строчкой можно заменить следующие 2
    StackItem* item = new StackItem; // создаем новый элемент стека
    item->point = point; //инициализируем данные в элементе
    item->next = stack; //корректируем указатель на следующий элемент
    stack = item; // теперь вершина стека указывает на добавленный элемент
}

Point Pop() // извлекает элемент из стека и возвращает его значение
{
    Point result; // здесь будет результат
    StackItem* temp; // временная переменная
    if (stack == nullptr) // если стек пуст
    {
        result.x = 0;   // то операция извлечения невозможна
        result.y = 0;   // пока мы не умеем реагировать на такую ситуацию
        return result;  // поэтому пока возвращаем Point {0,0}
    }
    result = stack->point; //записываем возвращаемые данные
    temp = stack;   // запоминаем элемент на вершине стека
    stack = temp->next; // перемещаем вершину стека на следующий за извлекаемым элемент
    delete temp;    // освобождаем память, занятую элементом на вершине
    return result; // возвращаем результат
}

Point FindPosition(char maze[15][15])
{
    Point p = { -1 };
    for (int i = 0; i < 15; i++)  // цикл пробегает массив по строкам
    {
        for (int j = 0; j < 15; j++) // цикл пробегает массив по столбцам
        {
            if (maze[i][j] == 'P')
            {
                return p = { i,j };
            }
        }
    }
    return p;
}

bool isMazeValid(Point player, char maze[15][15])
{
    Push(player); // помещаем координаты затравочного пикселя в стек
    while (!IsEmpty()) // пока стек не пуст
    {
        Point p = Pop();  // извлекаем пиксел из стека
        if (maze[p.x][p.y] == 'E')
            return true;
        if (maze[p.x][p.y] != '?') // если ему не присвоено значение заливки
            maze[p.x][p.y] = '?'; // заливаем

        if (maze[p.x + 1][p.y] != '?' && maze[p.x + 1][p.y] != '#') // проверяем пиксел справа от текущего
            Push(Point{ p.x + 1, p.y }); // если он не закрашен и не является границей, то помещаем его координаты в стек
        if (maze[p.x - 1][p.y] != '?' && maze[p.x - 1][p.y] != '#') // то же для левого
            Push(Point{ p.x - 1, p.y });
        if (maze[p.x][p.y - 1] != '?' && maze[p.x][p.y - 1] != '#') // то же для верхнего
            Push(Point{ p.x, p.y - 1 });
        if (maze[p.x][p.y + 1] != '?' && maze[p.x][p.y + 1] != '#') // то же для нижнего
            Push(Point{ p.x, p.y + 1 });
    }
    return false;
}

bool CanMoveToExit(char maze[15][15])
{
    Point player = FindPosition(maze);
    if (player.x == -1) return false;
    return isMazeValid(player, maze);
}

/*
Создайте функцию, которая проверяет достижимость выхода из лабиринта.
Функция возвращает в качестве результата новый список, в который включены только те товары, цена которых
лежит в указанном диапазоне цен.

1. Функция должна иметь имя CanMoveToExit
2. Функция в качестве параметров должна принимать следующее:
- первый параметр - символьный двумерный массив размером 15х15 элементов

3. Функция должна возвращать true, если из позиции игрока можно достичь любого из выходов и false в противном случае.

Тип возвращаемого результата - bool.

Этапы решения задачи:

Определите позицию игрока в лабиринте, если таковой нет, то возвращайте false, иначе считайте найденные координаты координатами затравочного пискеля.
Используя алгоритм заполнения гранично-определенной области с затравкой на основе стека определите, возможно ли достичь выхода. Достижением выхода считается факт, что вы при анализе очередного пикселя наткyулись на пиксель E. Если такой пиксель не будет найден - лабиринт непроходим.
Граничным символом в вашей задаче будет символ стены #. В процессе заливки лабиринта вы меняете любые отличные от # символы на символ - заполнитель. Пусть, например им будет символ "?".

    !!!!! ВАЖНО !!!!!
    В данном файле разрешается разместить кроме кода требуемой функции - код любых других вспомогательных
    функций. Никакой функции main() в этом файле быть не должно.
    Если вы хотите испытать и отладить вашу функцию - пишите код в файле Example.cpp проекта Example данного решения
    Для этого задайте в качестве запускаемого проекта проект Example.

    ДЛЯ АВТОМАТИЧЕСКОГО ТЕСТИРОВАНИЯ  проверки правильности работы вашего задания - сделайте запукаемым проект
    Tests и запустите его. Если функция написана правильно - все тесты должны успешно выполниться
    (зеленый цвет в консоли). Если ваша функция работает некорректно - в консоли будут сообщения красным цветом
*/
